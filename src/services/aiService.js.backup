import OpenAI from 'openai';

class AIService {
  constructor() {
    this.openai = null;
    this.isReady = false;
    this.conversationHistory = [];
    this.maxHistoryLength = 20; // æœ€å¤§20ä»¶ã®ä¼šè©±ã‚’è¨˜æ†¶
    this.systemPrompt = ''; // åˆæœŸåŒ–æ™‚ã«è¨­å®š
    this.model = 'gpt-4.1-mini';
  }

  async initialize(apiKey, systemPrompt, onProgress) {
    if (this.isReady) return;

    try {
      if (onProgress) {
        onProgress({ text: 'OpenAI APIã«æ¥ç¶šä¸­...' });
      }

      this.openai = new OpenAI({
        apiKey: apiKey,
        dangerouslyAllowBrowser: true // Electronç’°å¢ƒã§ã¯å¿…è¦
      });

      // ã‚·ã‚¹ãƒ†ãƒ ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’è¨­å®š
      this.systemPrompt = systemPrompt || 'ã‚ãªãŸã¯å¯æ„›ã„ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚';

      this.isReady = true;
      console.log('AI Service ready with OpenAI!');
      console.log('Model:', this.model);
      console.log('System Prompt:', this.systemPrompt);

      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰ä¼šè©±å±¥æ­´ã‚’å¾©å…ƒ
      this.loadConversationHistory();

    } catch (error) {
      console.error('Failed to initialize AI:', error);
      throw error;
    }
  }

  async chat(message, onStream, options = {}) {
    if (!this.isReady) {
      throw new Error('AI Service not initialized');
    }

    try {
      const {
        model = this.model,
        temperature = undefined,
        systemPrompt = this.systemPrompt,
        saveToHistory = true
      } = options;

      // ä¼šè©±å±¥æ­´ã«è¿½åŠ 
      if (saveToHistory) {
        this.conversationHistory.push({
          role: 'user',
          content: message
        });

        // å±¥æ­´ãŒé•·ã™ãã‚‹å ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
        if (this.conversationHistory.length > this.maxHistoryLength) {
          this.conversationHistory = this.conversationHistory.slice(-this.maxHistoryLength);
        }
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’æ§‹ç¯‰
      const messages = [
        {
          role: 'system',
          content: systemPrompt
        },
        ...(saveToHistory ? this.conversationHistory : [{ role: 'user', content: message }])
      ];

      // OpenAI APIã‚’å‘¼ã³å‡ºã—ï¼ˆã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ï¼‰
      const apiParams = {
        model: model,
        messages: messages,
        stream: true,
      };

      // temperatureãŒæŒ‡å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®ã¿è¿½åŠ ï¼ˆGPT-4.1ãªã©ã§ä½¿ç”¨ï¼‰
      if (temperature !== undefined) {
        apiParams.temperature = temperature;
      }

      const stream = await this.openai.chat.completions.create(apiParams);

      let fullResponse = '';

      // ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’å‡¦ç†
      for await (const chunk of stream) {
        const content = chunk.choices[0]?.delta?.content || '';
        if (content) {
          fullResponse += content;
          if (onStream) {
            onStream(content, fullResponse);
          }
        }
      }

      // ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®è¿”ç­”ã‚’å±¥æ­´ã«è¿½åŠ 
      if (saveToHistory) {
        this.conversationHistory.push({
          role: 'assistant',
          content: fullResponse
        });

        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
        this.saveConversationHistory();
      }

      return fullResponse;

    } catch (error) {
      console.error('Chat error:', error);
      throw error;
    }
  }

  // ãƒ„ãƒ¼ãƒ«ï¼ˆFunction callingï¼‰ä»˜ãã§ãƒãƒ£ãƒƒãƒˆ
  async chatWithTools(message, tools, onStream) {
    if (!this.isReady) {
      throw new Error('AI Service not initialized');
    }

    try {
      // ä¼šè©±å±¥æ­´ã«è¿½åŠ 
      this.conversationHistory.push({
        role: 'user',
        content: message
      });

      // å±¥æ­´ãŒé•·ã™ãã‚‹å ´åˆã¯å¤ã„ã‚‚ã®ã‚’å‰Šé™¤
      if (this.conversationHistory.length > this.maxHistoryLength) {
        this.conversationHistory = this.conversationHistory.slice(-this.maxHistoryLength);
      }

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’æ§‹ç¯‰
      const messages = [
        {
          role: 'system',
          content: this.systemPrompt
        },
        ...this.conversationHistory
      ];

      // OpenAI APIã‚’å‘¼ã³å‡ºã—ï¼ˆãƒ„ãƒ¼ãƒ«ä»˜ãï¼‰
      const response = await this.openai.chat.completions.create({
        model: this.model,
        messages: messages,
        tools: tools,
        tool_choice: 'auto',
      });

      const assistantMessage = response.choices[0].message;

      // ãƒ„ãƒ¼ãƒ«å‘¼ã³å‡ºã—ãŒã‚ã‚‹ã‹ç¢ºèª
      if (assistantMessage.tool_calls && assistantMessage.tool_calls.length > 0) {
        // assistantãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ï¼ˆtool_callsã‚’å«ã‚€ï¼‰ã‚’å±¥æ­´ã«è¿½åŠ 
        this.conversationHistory.push({
          role: 'assistant',
          content: assistantMessage.content || null,
          tool_calls: assistantMessage.tool_calls
        });

        return {
          type: 'tool_calls',
          tool_calls: assistantMessage.tool_calls,
          message: assistantMessage
        };
      }

      // é€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆå¿œç­”
      const fullResponse = assistantMessage.content || '';

      // ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®è¿”ç­”ã‚’å±¥æ­´ã«è¿½åŠ 
      this.conversationHistory.push({
        role: 'assistant',
        content: fullResponse
      });

      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      this.saveConversationHistory();

      if (onStream) {
        onStream(fullResponse, fullResponse);
      }

      return {
        type: 'text',
        content: fullResponse
      };

    } catch (error) {
      console.error('Chat with tools error:', error);
      throw error;
    }
  }

  // ãƒ„ãƒ¼ãƒ«å®Ÿè¡Œçµæœã‚’è¿½åŠ ã—ã¦å†åº¦ãƒãƒ£ãƒƒãƒˆ
  async continueWithToolResult(toolCallId, toolName, toolResult, onStream) {
    try {
      // ãƒ„ãƒ¼ãƒ«ã®å®Ÿè¡Œçµæœã‚’ä¼šè©±å±¥æ­´ã«è¿½åŠ 
      this.conversationHistory.push({
        role: 'tool',
        tool_call_id: toolCallId,
        name: toolName,
        content: JSON.stringify(toolResult)
      });

      // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é…åˆ—ã‚’æ§‹ç¯‰
      const messages = [
        {
          role: 'system',
          content: this.systemPrompt
        },
        ...this.conversationHistory
      ];

      // å†åº¦APIã‚’å‘¼ã³å‡ºã—
      const response = await this.openai.chat.completions.create({
        model: this.model,
        messages: messages,
      });

      const fullResponse = response.choices[0].message.content || '';

      // ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®è¿”ç­”ã‚’å±¥æ­´ã«è¿½åŠ 
      this.conversationHistory.push({
        role: 'assistant',
        content: fullResponse
      });

      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
      this.saveConversationHistory();

      if (onStream) {
        onStream(fullResponse, fullResponse);
      }

      return fullResponse;

    } catch (error) {
      console.error('Continue with tool result error:', error);
      throw error;
    }
  }

  // ä¼šè©±å±¥æ­´ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
  saveConversationHistory() {
    try {
      localStorage.setItem('conversationHistory', JSON.stringify(this.conversationHistory));
    } catch (error) {
      console.error('Failed to save conversation history:', error);
    }
  }

  // ä¼šè©±å±¥æ­´ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
  loadConversationHistory() {
    try {
      const saved = localStorage.getItem('conversationHistory');
      if (saved) {
        this.conversationHistory = JSON.parse(saved);
        console.log('Loaded conversation history:', this.conversationHistory.length, 'messages');
      }
    } catch (error) {
      console.error('Failed to load conversation history:', error);
      this.conversationHistory = [];
    }
  }

  // ä¼šè©±å±¥æ­´ã‚’ã‚¯ãƒªã‚¢
  clearHistory() {
    this.conversationHistory = [];
    localStorage.removeItem('conversationHistory');
  }

  getConversationHistory() {
    return [...this.conversationHistory];
  }

  // æŒ¨æ‹¶æ¤œå‡º
  detectGreeting(text) {
    const lowerText = text.toLowerCase();
    const greetings = [
      'ã“ã‚“ã«ã¡ã¯', 'ã“ã‚“ã°ã‚“ã¯', 'ãŠã¯ã‚ˆã†', 'ã‚„ã‚', 'ãƒãƒ­ãƒ¼',
      'hello', 'hi', 'hey', 'ã‚ˆã‚ã—ã', 'ã¯ã˜ã‚ã¾ã—ã¦'
    ];

    return greetings.some(greeting => lowerText.includes(greeting));
  }

  // æ„Ÿæƒ…åˆ†æï¼ˆæ”¹è‰¯ç‰ˆï¼‰
  analyzeEmotion(text) {
    const lowerText = text.toLowerCase();

    const emotions = {
      happy: [
        'å¬‰ã—ã„', 'æ¥½ã—ã„', 'happy', 'joy', 'å–œ', 'ç¬‘',
        'ã‚ãƒ¼ã„', 'ã‚„ã£ãŸ', 'ã‚ˆã‹ã£ãŸ', 'ç´ æ•µ', 'ç´ æ™´ã‚‰ã—ã„',
        'ã‚ã‚ŠãŒã¨ã†', 'æ„Ÿè¬', 'ã«ã“ã«ã“', 'âœ¨', 'ğŸ’–'
      ],
      sad: [
        'æ‚²ã—ã„', 'å¯‚ã—ã„', 'sad', 'sorry', 'æ®‹å¿µ',
        'ã¤ã‚‰ã„', 'æ³£', 'ã”ã‚ã‚“', 'ç”³ã—è¨³', 'æ¶™'
      ],
      angry: [
        'æ€’', 'angry', 'mad', 'ã‚¤ãƒ©ã‚¤ãƒ©', 'ã‚€ã‹ã¤',
        'ãµã–ã‘', 'ã‚„ã‚', 'ã ã‚', 'è¨±ã•'
      ],
      surprised: [
        'é©š', '!?', 'wow', 'amazing', 'ã³ã£ãã‚Š',
        'ã™ã”ã„', 'ã¾ã•ã‹', 'ãˆã£', 'ãŠãŠ', 'æœ¬å½“'
      ],
      thinking: [
        'è€ƒãˆ', 'æ€', 'ã†ãƒ¼ã‚“', 'ãˆãƒ¼ã¨', 'ãã†ã§ã™ã­',
        'ã‹ã‚‚', 'ã§ã—ã‚‡ã†', 'ã ã¨æ€', 'ã‹ãª'
      ]
    };

    // æ„Ÿæƒ…ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—
    const scores = {};
    for (const [emotion, keywords] of Object.entries(emotions)) {
      scores[emotion] = keywords.filter(keyword =>
        lowerText.includes(keyword)
      ).length;
    }

    // æœ€ã‚‚é«˜ã„ã‚¹ã‚³ã‚¢ã®æ„Ÿæƒ…ã‚’è¿”ã™
    let maxScore = 0;
    let detectedEmotion = 'neutral';

    for (const [emotion, score] of Object.entries(scores)) {
      if (score > maxScore) {
        maxScore = score;
        detectedEmotion = emotion;
      }
    }

    // è¤‡æ•°ã®æ„Ÿæƒ…è¨˜å·ãŒã‚ã‚‹å ´åˆã®èª¿æ•´
    if (text.includes('ï¼') && text.includes('ï¼Ÿ')) {
      return 'surprised';
    } else if (text.includes('ï¼') && maxScore === 0) {
      return 'happy';
    }

    return detectedEmotion;
  }

  destroy() {
    this.saveConversationHistory();
    this.openai = null;
    this.isReady = false;
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
const aiService = new AIService();
export default aiService;
